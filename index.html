<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Koffer-Tetris</title>
<style>
    html, body {
        margin: 0;
        padding: 0;
        background: #1c1c1c;
        touch-action: none;
        overflow: hidden;
        user-select: none;
        height: 100%;
        width: 100%;
    }

    #hint {
        color: white;
        text-align: center;
        font-size: 18px;
        padding: 8px;
        background: #2a2a2a;
        font-family: sans-serif;
    }

    #game-container {
        display: flex;
        justify-content: center;
        align-items: center;
        width: 100%;
    }

    canvas {
        background: #3a3a3a;
        display: block;
        border: 3px solid #202020;
        border-radius: 8px;
        image-rendering: pixelated;
    }

    #popup {
        display: none;
        position: fixed;
        top: 50%; left: 50%;
        transform: translate(-50%, -50%);
        background: #ffffff;
        padding: 30px;
        font-size: 22px;
        text-align: center;
        border-radius: 15px;
        width: 80%;
        max-width: 400px;
        z-index: 99;
        font-family: sans-serif;
        box-shadow: 0 0 20px rgba(0,0,0,0.5);
    }
</style>
</head>

<body>
<div id="hint">ðŸ‘‰ Tipp auf den Bildschirm = drehen | ðŸ‘‰ Nach unten drÃ¼cken = sofort ablegen</div>
<div id="game-container"><canvas id="game"></canvas></div>

<div id="popup">
    <b>Super, alle GepÃ¤ckstÃ¼cke sind verstaut, jetzt kann es losgehen!</b><br><br>
    Begib dich zur Boardingtreppe bei:<br><br>
    <b>N 52Â° 31.XXX<br>E 13Â° 31.YYY</b>
</div>

<script>
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");
const popup = document.getElementById("popup");
const hint = document.getElementById("hint");

let cols = 10;
let rows = 20;
let scale = 30;

let grid = [];
let currentPiece = null;
let dropInterval = 500;
let lastDrop = 0;
let gameOver = false;

// â˜… Kofferfarben
const luggageColors = ["#c77b30", "#a0522d", "#8b5a2b", "#d2b48c", "#b5651d"];

// â˜… verschiedene Kofferformen
const pieces = [
    [[1,1,1,1]],
    [[1,1],[1,1]],
    [[0,1,0],[1,1,1]],
    [[1,0,0],[1,1,1]],
    [[0,0,1],[1,1,1]],
    [[1,1,0],[0,1,1]],
    [[0,1,1],[1,1,0]]
];

function makeGrid() {
    grid = Array.from({length: rows}, () => Array(cols).fill(0));
}

function resizeCanvas() {
    const availW = Math.floor(window.innerWidth * 0.98);
    let availH;

    // Handy?
    if (/Mobi|Android|iPhone|iPad|iPod/i.test(navigator.userAgent)) {
        availH = Math.floor(window.innerHeight - (hint.offsetHeight + 20));
    } else {
        // Desktop MindesthÃ¶he
        availH = Math.floor(window.innerHeight * 0.90);
    }

    scale = Math.floor(availW / cols);
    if (scale < 20) scale = 20;

    rows = Math.floor(availH / scale);
    if (rows < 16) rows = 16;

    canvas.width = cols * scale;
    canvas.height = rows * scale;

    makeGrid();
}

function spawnPiece() {
    const shape = JSON.parse(JSON.stringify(pieces[Math.floor(Math.random()*pieces.length)]));
    currentPiece = {
        shape,
        x: Math.floor(cols/2) - 1,
        y: 0,
        color: luggageColors[Math.floor(Math.random()*luggageColors.length)]
    };
}

function rotate(piece) {
    const newShape = piece.shape[0].map((_,i)=>
        piece.shape.map(row=>row[i]).reverse()
    );
    return newShape;
}

function collide() {
    for (let y=0; y<currentPiece.shape.length; y++){
        for (let x=0; x<currentPiece.shape[y].length; x++){
            if (currentPiece.shape[y][x] === 1) {
                let px = currentPiece.x + x;
                let py = currentPiece.y + y;
                if (px < 0 || px >= cols || py >= rows) return true;
                if (py >= 0 && grid[py][px] !== 0) return true;
            }
        }
    }
    return false;
}

function mergePiece() {
    for (let y=0; y<currentPiece.shape.length; y++){
        for (let x=0; x<currentPiece.shape[y].length; x++){
            if (currentPiece.shape[y][x] === 1){
                grid[currentPiece.y + y][currentPiece.x + x] = currentPiece.color;
            }
        }
    }
}

function hardDrop() {
    while (!collide()) {
        currentPiece.y++;
    }
    currentPiece.y--; 
    mergePiece();
    spawnPiece();
}

function update(time=0) {
    if (gameOver) return;

    if (time - lastDrop > dropInterval) {
        currentPiece.y++;
        if (collide()) {
            currentPiece.y--;
            mergePiece();
            spawnPiece();
        }
        lastDrop = time;
    }

    draw();
    requestAnimationFrame(update);
}

function draw() {
    ctx.clearRect(0,0,canvas.width,canvas.height);

    // â˜… GepÃ¤ckraum-Optik
    ctx.fillStyle = "#2d2d2d";
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // leichte Linien
    ctx.strokeStyle = "rgba(255,255,255,0.06)";
    for (let x=0; x<=cols; x++){
        ctx.beginPath();
        ctx.moveTo(x*scale,0);
        ctx.lineTo(x*scale,canvas.height);
        ctx.stroke();
    }
    for (let y=0; y<=rows; y++){
        ctx.beginPath();
        ctx.moveTo(0,y*scale);
        ctx.lineTo(canvas.width,y*scale);
        ctx.stroke();
    }

    // â˜… Koffer im Grid
    for (let y=0; y<rows; y++){
        for (let x=0; x<cols; x++){
            if (grid[y][x] !== 0){
                drawLuggage(x*scale, y*scale, grid[y][x]);
            }
        }
    }

    // â˜… aktueller Koffer
    for (let y=0; y<currentPiece.shape.length; y++){
        for (let x=0; x<currentPiece.shape[y].length; x++){
            if (currentPiece.shape[y][x] === 1){
                drawLuggage(
                    (currentPiece.x + x)*scale,
                    (currentPiece.y + y)*scale,
                    currentPiece.color
                );
            }
        }
    }

    // â˜… Spielfeldbegrenzungen
    ctx.strokeStyle = "#111";
    ctx.lineWidth = 4;

    ctx.strokeRect(0,0,canvas.width,canvas.height);
}

function drawLuggage(x,y,color){
    ctx.fillStyle = color;
    ctx.fillRect(x+2,y+2,scale-4,scale-4);
    ctx.strokeStyle = "#000";
    ctx.lineWidth = 2;
    ctx.strokeRect(x+2,y+2,scale-4,scale-4);
}

// Eingaben
document.addEventListener("keydown", e =>{
    if (e.key === "ArrowLeft"){
        currentPiece.x--;
        if (collide()) currentPiece.x++;
    }
    if (e.key === "ArrowRight"){
        currentPiece.x++;
        if (collide()) currentPiece.x--;
    }
    if (e.key === "ArrowUp"){
        let old = currentPiece.shape;
        currentPiece.shape = rotate(currentPiece);
        if (collide()) currentPiece.shape = old;
    }
    if (e.key === "ArrowDown"){
        hardDrop();
    }
});

canvas.addEventListener("pointerdown", ()=>{
    let old = currentPiece.shape;
    currentPiece.shape = rotate(currentPiece);
    if (collide()) currentPiece.shape = old;
});

// Start
resizeCanvas();
spawnPiece();
requestAnimationFrame(update);

// Nach 60 Sekunden stoppen
setTimeout(()=>{
    gameOver = true;
    popup.style.display = "block";
}, 60000);

window.addEventListener("resize", resizeCanvas);
</script>
</body>
</html>