<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>Gepäck-Tetris</title>
<style>
html, body {
  margin:0;
  padding:0;
  height:100%;
  background: url('https://media.istockphoto.com/id/1440975206/de/foto/graustufenaufnahme-des-frachtraums-eines-flugzeugs.jpg?s=612x612&w=0&k=20&c=zHbbYiv35OtqRe7T7EEuxIQeko2mkwpk-DsX9b8Z2gM=') center center / cover no-repeat;
  font-family:sans-serif;
  overflow:hidden;
}
#hint {
  color:white;
  text-align:center;
  padding:8px;
  background:rgba(0,0,0,0.6);
  font-size:16px;
  position:fixed;
  width:100%;
  z-index:10;
}
#wrap {
  width:100%;
  height:100%;
  display:flex;
  justify-content:center;
  align-items:center;
}
canvas {
  touch-action:none;
  display:block;
  background: transparent; /* wichtig, damit Hintergrund sichtbar bleibt */
  border-radius:10px;
}
#popup {
  display:none;
  position:fixed;
  left:50%;
  top:50%;
  transform:translate(-50%,-50%);
  background:white;
  padding:20px;
  border-radius:12px;
  font-size:18px;
  text-align:center;
  z-index:20;
}
</style>
</head>
<body>
<div id="hint">Tippen = drehen · Wischen = bewegen · Wischen runter = direkt ablegen</div>
<div id="wrap"><canvas id="game" tabindex="0"></canvas></div>
<div id="popup">
  Super, alle Gepäckstücke sind verstaut!<br>
Jetzt kann es endlich losgehen<br><br>
  Begib dich zur Boardingtreppe bei:<br><br>
  <b>N 52° 31.XXX</b><br>
  <b>E 13° 31.YYY</b>
</div>

<script>
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");
let cols = 10, rows = 20, scale = 32;
let grid=[], currentPiece=null, lastDrop=0, dropInterval=550;

const shapes=[
  [[1,1,1,1]],
  [[1,1],[1,1]],
  [[0,1,0],[1,1,1]],
  [[1,1,0],[0,1,1]],
  [[0,1,1],[1,1,0]]
];
const colors=["#FFB3BA","#FFDFBA","#FFFFBA","#BAFFC9","#BAE1FF"];

function resize(){
  const availW = window.innerWidth*0.95;
  const availH = window.innerHeight*0.88;
  const scaleW = Math.floor(availW/cols);
  const scaleH = Math.floor(availH/rows);
  scale = Math.max(22, Math.min(scaleW, scaleH));
  canvas.width = cols*scale;
  canvas.height = rows*scale;
  grid = Array.from({length: rows}, ()=>Array(cols).fill(0));
  canvas.focus();
}
resize();
window.addEventListener("resize", resize);

function newPiece(){
  const s=JSON.parse(JSON.stringify(shapes[Math.floor(Math.random()*shapes.length)]));
  return {shape:s, color:colors[Math.floor(Math.random()*colors.length)], x:Math.floor(cols/2 - s[0].length/2), y:0};
}

function collide(){
  for(let r=0;r<currentPiece.shape.length;r++){
    for(let c=0;c<currentPiece.shape[r].length;c++){
      if(!currentPiece.shape[r][c]) continue;
      const nx=currentPiece.x+c, ny=currentPiece.y+r;
      if(nx<0||nx>=cols||ny>=rows) return true;
      if(ny>=0 && grid[ny][nx]) return true;
    }
  }
  return false;
}

function merge(){
  for(let r=0;r<currentPiece.shape.length;r++){
    for(let c=0;c<currentPiece.shape[r].length;c++){
      if(currentPiece.shape[r][c]) grid[currentPiece.y+r][currentPiece.x+c]=currentPiece.color;
    }
  }
}

function sweep(){
  for(let r=rows-1;r>=0;r--){
    if(grid[r].every(x=>x)){ grid.splice(r,1); grid.unshift(Array(cols).fill(0)); }
  }
}

function rotate(piece){
  const old=piece.shape;
  const n=old.length, m=old[0].length;
  let rotated=[];
  for(let c=0;c<m;c++){
    rotated[c]=[];
    for(let r=n-1;r>=0;r--) rotated[c][n-1-r]=old[r][c];
  }
  piece.shape=rotated;
  if(collide()) piece.shape=old;
}

function hardDrop(){
  while(!collide()) currentPiece.y++;
  currentPiece.y--;
  merge();
  sweep();
  currentPiece=newPiece();
  if(collide()) grid=Array.from({length:rows},()=>Array(cols).fill(0));
}

// === Koffer zeichnen ===
function drawLuggage(x,y,color){
  const r = scale*0.15;
  ctx.fillStyle=color;
  ctx.beginPath();
  ctx.moveTo(x+r,y); ctx.lineTo(x+scale-r,y); ctx.quadraticCurveTo(x+scale,y,x+scale,y+r);
  ctx.lineTo(x+scale,y+scale-r); ctx.quadraticCurveTo(x+scale,y+scale,x+scale-r,y+scale);
  ctx.lineTo(x+r,y+scale); ctx.quadraticCurveTo(x,y+scale,x,y+scale-r);
  ctx.lineTo(x,y+r); ctx.quadraticCurveTo(x,y,x+r,y);
  ctx.fill();
  ctx.strokeStyle="rgba(0,0,0,0.3)";
  ctx.lineWidth=Math.max(2,scale*0.05);
  ctx.stroke();
  ctx.fillStyle="#555"; ctx.fillRect(x+scale*0.3,y+scale*0.08,scale*0.4,scale*0.12);
  ctx.strokeStyle="#333"; ctx.lineWidth=Math.max(1,scale*0.03);
  ctx.beginPath();
  ctx.moveTo(x+scale*0.15,y+scale*0.35); ctx.lineTo(x+scale*0.85,y+scale*0.35);
  ctx.moveTo(x+scale*0.15,y+scale*0.65); ctx.lineTo(x+scale*0.85,y+scale*0.65);
  ctx.stroke();
  ctx.fillStyle="#222"; ctx.beginPath();
  ctx.arc(x+scale*0.2,y+scale*0.95,scale*0.07,0,Math.PI*2);
  ctx.arc(x+scale*0.8,y+scale*0.95,scale*0.07,0,Math.PI*2);
  ctx.fill();
}

function draw(){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  for(let r=0;r<rows;r++){ for(let c=0;c<cols;c++){ if(grid[r][c]) drawLuggage(c*scale,r*scale,grid[r][c]); } }
  if(currentPiece){
    for(let r=0;r<currentPiece.shape.length;r++){
      for(let c=0;c<currentPiece.shape[r].length;c++){
        if(currentPiece.shape[r][c]) drawLuggage((currentPiece.x+c)*scale,(currentPiece.y+r)*scale,currentPiece.color);
      }
    }
  }
}

document.addEventListener("keydown",e=>{
  if(e.key==="ArrowLeft"){ currentPiece.x--; if(collide()) currentPiece.x++; }
  if(e.key==="ArrowRight"){ currentPiece.x++; if(collide()) currentPiece.x--; }
  if(e.key==="ArrowUp"){ rotate(currentPiece); }
  if(e.key==="ArrowDown"){ hardDrop(); }
});

let sx=0,sy=0,st=0;
canvas.addEventListener("pointerdown",e=>{ sx=e.clientX; sy=e.clientY; st=Date.now(); });
canvas.addEventListener("pointerup",e=>{
  const dx=e.clientX-sx, dy=e.clientY-sy, dt=Date.now()-st;
  if(Math.abs(dx)<10&&Math.abs(dy)<10&&dt<200){ rotate(currentPiece); return; }
  if(Math.abs(dx)>Math.abs(dy)){
    if(dx>20){ currentPiece.x++; if(collide()) currentPiece.x--; } 
    else if(dx<-20){ currentPiece.x--; if(collide()) currentPiece.x++; }
  } else if(dy>20){ hardDrop(); }
});

function loop(ts){
  if(!currentPiece) currentPiece=newPiece();
  if(ts-lastDrop>dropInterval){
    currentPiece.y++;
    if(collide()){ currentPiece.y--; merge(); sweep(); currentPiece=newPiece(); if(collide()) grid=Array.from({length:rows},()=>Array(cols).fill(0)); }
    lastDrop=ts;
  }
  draw();
  requestAnimationFrame(loop);
}
currentPiece=newPiece();
requestAnimationFrame(loop);

setTimeout(()=>{ document.getElementById("popup").style.display="block"; },60000);

</script>
</body>
</html>