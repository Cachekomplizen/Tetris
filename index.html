<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="UTF-8">
<title>Gepäck-Tetris Flughafen Edition</title>
<style>
  body { margin:0; display:flex; justify-content:center; align-items:center; height:100vh; background:#87ceeb; font-family:sans-serif; flex-direction:column; }
  canvas { background:#222; display:block; touch-action: none; margin-top:40px; }
  #hint {
    position:fixed;
    top:10px;
    left:50%;
    transform:translateX(-50%);
    background:rgba(255,255,255,0.8);
    padding:5px 10px;
    border-radius:5px;
    font-size:16px;
    font-weight:bold;
    z-index:10;
  }
  #popup {
    display:none;
    position:fixed;
    top:50%;
    left:50%;
    transform:translate(-50%, -50%);
    background:white;
    padding:20px;
    border-radius:10px;
    box-shadow:0 0 10px rgba(0,0,0,0.5);
    font-size:18px;
    text-align:center;
    max-width:90%;
    z-index:10;
  }
</style>
</head>
<body>

<div id="hint">Einmal tippen für Drehung</div>
<canvas id="game" tabindex="0"></canvas>
<div id="popup">
  Super, alle Gepäckstücke sind verstaut<br>
Auch wenn nicht ganz so perfekt ;)<br><br>
Jetzt kann es losgehen.<br><br>
  Begib dich zur Boardingtreppe bei:<br>
  N 52° 31.XXX E13° 31.YYY
</div>

<script>
const canvas = document.getElementById('game');
canvas.focus();
const ctx = canvas.getContext('2d');

let scale, rows, cols, grid;
function resizeCanvas(){
  canvas.width = Math.min(window.innerWidth*0.9, 350);
  canvas.height = Math.min(window.innerHeight*0.8, 500);
  scale = Math.floor(canvas.width / 12);
  rows = Math.floor(canvas.height / scale);
  cols = 12;
  grid = Array.from({length: rows}, () => Array(cols).fill(0));
}
resizeCanvas();
window.addEventListener('resize', resizeCanvas);

// Blöcke
const pieces = [
  [[1,1,1,1]], [[1,1],[1,1]], [[0,1,0],[1,1,1]], [[1,1,0],[0,1,1]], [[0,1,1],[1,1,0]]
];

function randomPiece() { 
  const shape = pieces[Math.floor(Math.random()*pieces.length)];
  return {shape, x: Math.floor(cols/2 - shape[0].length/2), y: 0};
}

let current = randomPiece();

/* === drawLuggage() = realistische Koffer === */
function drawLuggage(x,y,color){
  const r = scale*0.15; // Rundung
  // Koffer-Körper
  ctx.fillStyle=color;
  ctx.beginPath();
  ctx.moveTo(x+r,y);
  ctx.lineTo(x+scale-r,y);
  ctx.quadraticCurveTo(x+scale,y,x+scale,y+r);
  ctx.lineTo(x+scale,y+scale-r);
  ctx.quadraticCurveTo(x+scale,y+scale,x+scale-r,y+scale);
  ctx.lineTo(x+r,y+scale);
  ctx.quadraticCurveTo(x,y+scale,x,y+scale-r);
  ctx.lineTo(x,y+r);
  ctx.quadraticCurveTo(x,y,x+r,y);
  ctx.fill();
  // Kanten
  ctx.strokeStyle="rgba(0,0,0,0.3)";
  ctx.lineWidth=Math.max(2,scale*0.05);
  ctx.stroke();
  // Griff oben
  ctx.fillStyle="#555";
  ctx.fillRect(x+scale*0.3, y+scale*0.08, scale*0.4, scale*0.12);
  // Linien auf Kofferfront
  ctx.strokeStyle="#333";
  ctx.lineWidth=Math.max(1,scale*0.03);
  ctx.beginPath();
  ctx.moveTo(x+scale*0.15,y+scale*0.35);
  ctx.lineTo(x+scale*0.85,y+scale*0.35);
  ctx.moveTo(x+scale*0.15,y+scale*0.65);
  ctx.lineTo(x+scale*0.85,y+scale*0.65);
  ctx.stroke();
  // Rollen
  ctx.fillStyle="#222";
  ctx.beginPath();
  ctx.arc(x+scale*0.2,y+scale*0.95,scale*0.07,0,Math.PI*2);
  ctx.arc(x+scale*0.8,y+scale*0.95,scale*0.07,0,Math.PI*2);
  ctx.fill();
}

// Tastatur
document.addEventListener('keydown', e=>{ canvas.focus(); if(e.key==='ArrowLeft'){ current.x--; if(collide()) current.x++; } if(e.key==='ArrowRight'){ current.x++; if(collide()) current.x--; } if(e.key==='ArrowDown'){ current.y++; if(collide()){ current.y--; merge(); current = randomPiece(); sweep(); } } if(e.key==='ArrowUp'){ rotate(current); } });

// Touch
let touchStartX=0, touchStartY=0;
canvas.addEventListener('touchstart', e=>{ const touch=e.touches[0]; touchStartX=touch.clientX; touchStartY=touch.clientY; });
canvas.addEventListener('touchend', e=>{ const touch=e.changedTouches[0]; const dx=touch.clientX-touchStartX; const dy=touch.clientY-touchStartY; if(Math.abs(dx)<10 && Math.abs(dy)<10){ rotate(current); return; } if(Math.abs(dx)>Math.abs(dy)){ if(dx>20){ current.x++; if(collide()) current.x--; } else if(dx<-20){ current.x--; if(collide()) current.x++; } } else { if(dy>20){ current.y++; if(collide()){ current.y--; merge(); current = randomPiece(); sweep(); } } } });

// Flugzeug
let plane={x:canvas.width/2 - scale*3, y:10, width:scale*6, height:scale*2, dir:1};
function drawPlane(){ ctx.fillStyle="#555"; ctx.fillRect(plane.x,plane.y,plane.width,plane.height); ctx.beginPath(); ctx.moveTo(plane.x+plane.width,plane.y); ctx.lineTo(plane.x+plane.width+scale*0.5,plane.y+plane.height/2); ctx.lineTo(plane.x+plane.width,plane.y+plane.height); ctx.closePath(); ctx.fill(); ctx.fillStyle="#444"; ctx.fillRect(plane.x+scale*1.5,plane.y-scale*0.5,scale*3,scale*0.5); ctx.fillRect(plane.x+scale*1.5,plane.y+plane.height,scale*3,scale*0.5); ctx.fillStyle="#666"; ctx.fillRect(plane.x,plane.y-scale*0.3,scale*0.5,scale*0.3);}
function updatePlane(){ plane.x+=plane.dir*1; if(plane.x<0 || plane.x+plane.width>canvas.width) plane.dir*=-1;}

// Kollisionsfunktionen etc. (collide, merge, sweep, rotate) unverändert
function collide(){ for(let r=0;r<current.shape.length;r++){ for(let c=0;c<current.shape[r].length;c++){ if(current.shape[r][c] && (grid[current.y+r] && grid[current.y+r][current.x+c]) !== 0) return true; } } return false; }
function merge(){ for(let r=0;r<current.shape.length;r++){ for(let c=0;c<current.shape[r].length;c++){ if(current.shape[r][c]) grid[current.y+r][current.x+c]=1; } } }
function sweep(){ for(let r=rows-1;r>=0;r--){ if(grid[r].every(cell=>cell!==0)){ grid.splice(r,1); grid.unshift(Array(cols).fill(0)); } } }
function rotate(piece){ const shape=piece.shape; const n=shape.length; const m=shape[0].length; const newShape=[]; for(let c=0;c<m;c++){ newShape[c]=[]; for(let r=n-1;r>=0;r--){ newShape[c][n-1-r]=shape[r][c]; } } piece.shape=newShape; if(collide()) piece.shape=shape; }

// Zeichnen Spielfeld + Koffer
function draw(){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  drawPlane();
  for(let r=0;r<rows;r++){ for(let c=0;c<cols;c++){ if(grid[r][c]) drawLuggage(c*scale,r*scale,"orange"); } }
  for(let r=0;r<current.shape.length;r++){ for(let c=0;c<current.shape[r].length;c++){ if(current.shape[r][c]){ const colors=["#FF5733","#33FF57","#3357FF","#F3FF33","#FF33F6"]; const color=colors[pieces.indexOf(current.shape)%colors.length]||"#FF0000"; drawLuggage((current.x+c)*scale,(current.y+r)*scale,color); } } }
}

// Spiel-Loop
function update(){ updatePlane(); current.y++; if(collide()){ current.y--; merge(); current=randomPiece(); sweep(); } draw(); }
let gameInterval=setInterval(update,500);

// 1-Minuten-Popup
setTimeout(()=>{ clearInterval(gameInterval); document.getElementById("popup").style.display="block"; },1*60*1000);
document.getElementById("popup").addEventListener("click", ()=>{ document.getElementById("popup").style.display="none"; });
</script>
</body>
</html>